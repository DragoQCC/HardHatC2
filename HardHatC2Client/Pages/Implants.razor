@page "/Implants"
@using HardHatCore.ApiModels.Plugin_BaseClasses;
@using HardHatCore.HardHatC2Client.Components;
@using HardHatCore.HardHatC2Client.Plugin_BaseClasses;
@using HardHatCore.HardHatC2Client.Components.ImplantCreation;
@using RestSharp
@using HardHatCore.HardHatC2Client.Services
@using System.Collections.ObjectModel
@using System.Linq
@using System.Diagnostics;
@using Blazored.LocalStorage
@using RestSharp.Authenticators;
@inject RestClient restClientDefault
@inject IToastService toastDefault
@inject NavigationManager navigationManagerDefault
@inject IDialogService dialogServiceDefault

<CascadingAuthenticationState>
    <AuthorizeView Roles="Operator,TeamLead">
        <Authorized>
            <br>
        <h3>Implants</h3>
            <MudTabs>
                <MudTabPanel Text="Table View / Creation">
            <br>
            <div class="container-fluid d-flex flex-grow-1" style="height:50vh; overflow-y:scroll">            
                @if (HideOfflineImplants)
                {
                    ImplantDisplayList = ImplantList.Where(x => x.Status == "Active").ToList();
                }
                else
                {
                    ImplantDisplayList = ImplantList.ToList();
                }
                <MudDataGrid Style="width:100%; height:50vh;" Class="flex-auto" HeaderClass="@GetHeaderClass()" Items="@ImplantDisplayList" T="ExtImplant_Base" ShowMenuIcon="true" QuickFilter="@FilterFunc1" FilterMode="DataGridFilterMode.ColumnFilterMenu" HorizontalScrollbar="true" Virtualize="true" FixedHeader="true" Hover="true" Dense="true" Elevation="10" Outlined="true" DragDropColumnReordering="@true" ApplyDropClassesOnDragStarted="@true" Hideable="true" ColumnResizeMode="ResizeMode.Container" ColumnsPanelReordering="true" RowContextMenuClick="RowRightClicked" ShowColumnOptions="false" DragIndicatorIcon="" @ref="implantDataGrid">
                    <ToolBarContent>
                        <MudText Typo="Typo.h6">Implants</MudText>
                        <MudSpacer />
                        <MudTextField @bind-Value="searchString1" Placeholder="Search" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
                        <MudToggleIconButton @bind-Toggled="@HideOfflineImplants" Color="Color.Primary" Icon="@Icons.Material.Filled.Visibility" ToggledIcon="@Icons.Material.Filled.VisibilityOff" Title="Hide Offline Implants" ToggledTitle="Hide Offline Implants" />
                    </ToolBarContent>
                    <Columns>
                        <PropertyColumn Property="x => x.Number" Title="#" />
                        <TemplateColumn Context="Rowcontext">
                            <CellTemplate>
                                <MudBadge Class="mud-badge-implant-table" Bordered="false" Overlap="false" Content=@ImplantInteract.SetPanelBadgeCount(Rowcontext.Item) Color="Color.Primary">
                                    <MudIcon Size="Size.Small" Class="mb-2 ms-2" Icon=@Icons.Material.Outlined.DesktopWindows Color=@SetColor(Rowcontext.Item.Metadata.Integrity)></MudIcon>
                                </MudBadge>
                            </CellTemplate>
                        </TemplateColumn>
                        <PropertyColumn Property="x => x.Status" Title="Status" />
                        <PropertyColumn Property="x => x.ExternalAddress" Title="External Address" />
                        <PropertyColumn Property="x => x.Metadata.ManagerName" Title="Manager" />
                        <PropertyColumn Property="x => x.ConnectionType" Title="Connection Type" />
                        <PropertyColumn Property="x => x.Metadata.Address" Title="Address" />
                        <PropertyColumn Property="x => x.Metadata.Hostname" Title="Hostname" />
                        <PropertyColumn Property="x => x.Metadata.Username" Title="Username" />
                        <PropertyColumn Property="x => x.Note" Title="Note" />
                        <PropertyColumn Property="x => x.Metadata.ProcessName" Title="Process Name" />
                        <PropertyColumn Property="x => x.Metadata.ProcessId" Title="Process Id" />
                        <PropertyColumn Property="x => x.Metadata.Integrity" Title="Integrity" />
                        <PropertyColumn Property="x => x.Metadata.Arch" Title="Arch" />
                        <PropertyColumn Property="x => x.Metadata.Sleep" Title="Sleep" />
                        <PropertyColumn Property="x => x.LastSeen" Title="Last Seen" />
                        <PropertyColumn Property="x => x.FirstSeen" Title="First Seen" />
                        <PropertyColumn Property="x => x.ImplantType" Title="Implant Type" />
                        <TemplateColumn Context="Rowcontext" Title="Options">
                            <CellTemplate>
                                <MudButtonGroup Color="Color.Primary" Variant="Variant.Outlined">
                                    <MudMenu @ref="implantTableMenu" Icon="@Icons.Material.Filled.ArrowDropDown">
                                                <MudMenuItem OnClick="() =>ContextMenuItems(0,SelectedImplantRow)">Interact</MudMenuItem>
                                                <MudMenuItem OnClick="() =>ContextMenuItems(1,SelectedImplantRow)">Note</MudMenuItem>
                                                <MudMenuItem OnClick="() =>ContextMenuItems(2,SelectedImplantRow)">Color</MudMenuItem>
                                                <MudMenuItem OnClick="() =>ContextMenuItems(3,SelectedImplantRow)">Exit</MudMenuItem>
                                    </MudMenu>
                                </MudButtonGroup>
                            </CellTemplate>
                        </TemplateColumn>
                    </Columns>
                </MudDataGrid>
            </div>
            <br>
            <ImplantCreation></ImplantCreation>
                </MudTabPanel>
                <br>
                <MudTabPanel Text="Graph View">
                    <MudPaper Height="1100px" Width="100%">
                        <ImplantGraph></ImplantGraph>
                    </MudPaper>
                </MudTabPanel>
                <br>
                <MudTabPanel Text="Compiled Implants">
                    <CompiledImplantTable></CompiledImplantTable>
                </MudTabPanel>
            </MudTabs>
        </Authorized>
    </AuthorizeView>
    <AuthorizeView Roles="Guest,Operator,TeamLead,Administrator">
        <NotAuthorized>
            <h1 class="text-center">Not Authorized</h1>
            <UnAuthorizedDialogBox></UnAuthorizedDialogBox>
        </NotAuthorized>
    </AuthorizeView>
</CascadingAuthenticationState>

@code {
    [Inject]
    private IDialogService dialogService { get; set; }
    // [Inject]
    // private static RestClient _restClient { get; set; }
    [Inject]
    private static IToastService toastService { get; set; }
    [Inject]
    private static NavigationManager Nav { get; set; }

    [Inject]
    public ILocalStorageService localStorage { get; set; }

    protected internal static ObservableCollection<ExtImplant_Base> ImplantList = new ObservableCollection<ExtImplant_Base>();
    //private static Dictionary<string, int> ImplantNumbers = new();
    //private static Dictionary<string, DateTime> ImplantFirstSeenDict = new();
    protected internal static List<ExtImplant_Base> ImplantDisplayList = new List<ExtImplant_Base>();
    protected internal ExtImplant_Base SelectedImplantRow { get; set; }
    private string ImplantTestID { get; set; }
    public Double OpacityValue { get; set; }
    private static bool Initialized = false;
    private bool success;
    private string[] errors = { };
    public MudDataGrid<ExtImplant_Base> implantDataGrid;
    private MudMenu implantTableMenu {get; set;}
    private int selectedRowNumber = -1;
    public static string PsCmd { get; set; }
    private static Stopwatch stopwatch = new Stopwatch();
    private static bool IsCurrentLocation { get; set; }
    public static bool HideOfflineImplants { get; set; }
    public delegate Task OnStateChangeDelegate();
    public static OnStateChangeDelegate OnStateChange;
    private static DateTime? LastRefresh { get; set; } = null;
    private string searchString1 = "";
    private bool OpenDialog { get; set; } = false;
    

    public static async Task SetPsCommand(string command)
    {
        PsCmd = command;
    }

    public static Color SetColor(string integrity)
    {
        if (integrity.Equals("high", StringComparison.CurrentCultureIgnoreCase))
        {
            return Color.Primary;
        }
        if (integrity.Equals("system", StringComparison.CurrentCultureIgnoreCase))
        {
            return Color.Error;
        }
        else if (integrity.Equals("medium", StringComparison.CurrentCultureIgnoreCase))
        {
            return Color.Info;
        }
        else if (integrity.Equals("low", StringComparison.CurrentCultureIgnoreCase))
        {
            return Color.Tertiary;
        }
        return Color.Info;
    }


    public string GetCellStyle(string columnName, ExtImplant_Base implant)
    {
        if (implant.Status.Equals("offline",StringComparison.CurrentCultureIgnoreCase))
        {
            return "opacity:.4";
        }
        else
        {
            return "opactity:1";
        }
    }


    public void HandleLeftClick(MouseEventArgs args)
    {
        //can handle left click inside the table
    }
    
    public async Task RowRightClicked(DataGridRowClickEventArgs<ExtImplant_Base> args)
    {
        await InvokeAsync(() =>
        {
            SelectedImplantRow = args.Item;
            implantTableMenu.ActivationEvent = MouseEvent.RightClick;
            implantTableMenu.Style = $"position:fixed !important; top:{args.MouseEventArgs.ClientY}px !important; left:{args.MouseEventArgs.ClientX}px !important; opacity:0;";
            implantTableMenu.ToggleMenu(args.MouseEventArgs);
            Console.WriteLine("Right Clicked");
            Console.WriteLine($"menu toggled, is open? {implantTableMenu.IsOpen}");
        });
    }

    internal static string GetHeaderClass()
    {
        if(MainLayout.IsDarkMode)
        {
            return "implant-table-header-dark";
        }
        else
        {
            return "implant-table-header";
        }
    }

    private bool FilterFunc1(ExtImplant_Base search) => FilterFunc(search, searchString1);

    private bool FilterFunc(ExtImplant_Base search, string searchString)
    {
        if (string.IsNullOrWhiteSpace(searchString))
            return true;
        //for each element in the array if it contains searchString then return true
        if (search.Metadata.Id.ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.Metadata.Sleep.ToString().ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.Metadata.Address.ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.Metadata.Arch.ToString().ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.Metadata.Hostname.ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.Metadata.Integrity.ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.LastSeen.ToString().ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.Metadata.ManagerName.ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.Metadata.Username.ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.Metadata.ProcessId.ToString().ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.Metadata.ProcessName.ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.ConnectionType.ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.ExternalAddress.ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        if (search.Status.ToLower().Contains(searchString.ToLower()))
        {
            return true;
        }
        return false;
    }

    public async Task ContextMenuItems(int options, ExtImplant_Base implant)
    {
        switch (options)
        {
            case 0:
                //Interact
                AddImplantToInteract(implant);
                break;
            case 1:
                //note
                //cause a mud popup where the user can select to add implants from the implant table that are not yet interacted with
                var diag_options = new DialogOptions { ClassBackground = "dialog-blur-class", MaxWidth = MaxWidth.Medium, FullWidth = true, DisableBackdropClick = true };
                var dialog = dialogService.Show<ImplantNoteDiag>("Add Note to Implant", diag_options);

                var result = await dialog.Result;
                if (!result.Canceled)
                {
                    string noteString = result.Data as string;
                    //result.Data should be a string, would need to call a hub fdunction to replicate to note to all clients
                    if (!String.IsNullOrEmpty(noteString))
                    {
                        await HardHatHubClient._hub.AddNoteToImplant(implant.Metadata.Id, noteString);
                    }
                }
                break;
            case 2:
                //color
                ShowInfoToast("Color is not implemented yet");
                break;
            case 3:
                //exit
                ShowInfoToast("Exit is not implemented yet");
                break;
        }
    }

    public static void AddImplantToInteract(ExtImplant_Base implant)
    {
        if (!ImplantInteract.InteractImplants.Contains(implant))
        {
            ImplantInteract.InteractImplants.Add(implant);
        }
        //compare the eng.ProcessId@eng.Address to the values in the Interact.ImpTabTitleDic dictionary, if it matches any of the values, then add it to the dictionary but its value is ng.ProcessId@eng.Address + a number that is equal to the number of values it matched in the dictionary

        if (ImplantInteract.ImpTabTitleDic.ContainsValue(implant.Metadata.ProcessId + "@" + implant.Metadata.Address) && ImplantInteract.ImpTabTitleDic.ContainsKey(implant.Metadata.Id) == false)
        {
            int count = 0;
            foreach (string key in ImplantInteract.ImpTabTitleDic.Keys)
            {
                if (ImplantInteract.ImpTabTitleDic[key] == implant.Metadata.ProcessId + "@" + implant.Metadata.Address)
                {
                    count++;
                }
                else if (ImplantInteract.ImpTabTitleDic[key] == implant.Metadata.ProcessId + "@" + implant.Metadata.Address + "(" + count + ")")
                {
                    count++;
                }
            }
            ImplantInteract.ImpTabTitleDic.Add(implant.Metadata.Id, implant.Metadata.ProcessId + "@" + implant.Metadata.Address + "(" + count + ")");
        }
        else if (!ImplantInteract.ImpTabTitleDic.ContainsKey(implant.Metadata.Id))
        {
            ImplantInteract.ImpTabTitleDic.Add(implant.Metadata.Id, implant.Metadata.ProcessId + "@" + implant.Metadata.Address);
        }
        //check if the current window is the same implant we are trying to interact with or not
        if (ImplantInteract.interactedImplantId != null && ImplantInteract.interactedImplantId != implant.Metadata.Id)
        {
            ImplantInteract.interactedImplantId = implant.Metadata.Id;
            ImplantInteract.interactedImpIdUpdated = true;
            ImplantInteract.ImplantTaskPanels.TryAdd(implant.Metadata.Id, new InteractWindowTaskCard());
        }
        Nav.NavigateTo("/ImplantInteract");
    }

    public static async Task UpdateImplantNote(string id, string note)
    {
        foreach (var imp in ImplantList)
        {
            if (imp.Metadata.Id == id)
            {
                imp.Note = note;
            }
        }
        await Task.Delay(500);
        await OnStateChange();
    }

    public static string FindManager(ExtImplant_Base currentimp, string managerName)
    {
        if (currentimp.ConnectionType.Equals("http", StringComparison.CurrentCultureIgnoreCase) || currentimp.ConnectionType.Equals("https", StringComparison.CurrentCultureIgnoreCase))
        {
            return "";
        }
        foreach (var man in Managers.managersList)
        {
            if (man.Name == managerName)
            {
                return man.connectionMode.ToString();
            }
        }
        return "";
    }

    public static async Task CreateImplant(ExtImplantCreateRequest_Base formData)
    {
        try
        {
            string resource = "/implants";
            var createObject = formData.Clone();

            var request = new RestRequest(resource, Method.Post);
            request.AddJsonBody(createObject);
            ShowInfoToast("Sending Request To Create Implant");
            await OnStateChange();
            // request.OnBeforeDeserialization = resp =>
            // {
            //     Console.WriteLine(resp.Content);
            // };
            var requestResponse = await Login._restClient.PostAsync<string>(request);
            if (requestResponse != null)
            {
                ShowSuccessToast(requestResponse);
            }
            //reset the form data object
            formData = new ExtImplantCreateRequest_Base();
            await OnStateChange();
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            Console.WriteLine(ex.StackTrace);
        }

    }

    public static async Task GetAllImplants()
    {
        string resource = "/implants";
        var request = new RestRequest(resource, Method.Get);
        try
        {
            var requestResponse = await Login._restClient.GetAsync<List<ExtImplant_Base>>(request);
            if (requestResponse != null)
            {
                foreach (ExtImplant_Base implantresponse in requestResponse)
                {
                    var implant = ImplantList.FirstOrDefault(x => x?.Metadata.Id == implantresponse.Metadata.Id, defaultValue: null);
                    if (implant != null)
                    {
                        implant.LastSeen = implantresponse.LastSeen;
                        implant.Metadata.Sleep = implantresponse.Metadata.Sleep;
                    }
                    else
                    {
                        ImplantList.Add(implantresponse);
                    }
                }
            }
        }
        catch(Exception ex)
        {
            Console.WriteLine(ex.Message);    

        }
    }

    public static async Task CheckInImplant(ExtImplant_Base implant)
    {
        //see if the implant is already in the list
        var Currentimplant = ImplantList.FirstOrDefault(x => x?.Metadata.Id == implant.Metadata.Id,defaultValue: null);
        if (Currentimplant != null)
        {
            // update the object with the new values
            Currentimplant.LastSeen = implant.LastSeen;
            Currentimplant.Metadata.Sleep = implant.Metadata.Sleep;
        }
        else
        {
            ImplantList.Add(implant);
        }
    }


    public static string GetImplantStatus(ExtImplant_Base implant)
    {
        // if implant LastSeen is in the past then Status is offline
        // add 5 seconds to the LastSeen to make sure the implant is still online
        int sleepTime = implant.Metadata.Sleep;
        //makes it so the ui wont auto timeout implants at sleep 0 unless they dont check in for 4-5 seconds
        if (sleepTime == 0)
        {
            sleepTime = 2;
        }
        if (implant.LastSeen.AddSeconds(sleepTime * 3) < DateTime.UtcNow)
        {
            implant.Status = "Offline";
            return "opacity:.4";
        }
        else
        {
            implant.Status = "Active";
            return "opactity:1";
        }
    }

    public static string LastSeenTimer(ExtImplant_Base implant)
    {
        string output = "";
        //based on lastSeen time use a timer and return the time since last seen in a string, print ms if less than 1 second print seconds if less than 1 minute print minutes if less than 1 hour print hours if less than 1 day print , only print the whole number
        var timeSinceLastSeen = DateTime.UtcNow - implant.LastSeen;
        //dont let the timeSinceLastSeen be negative
        if (timeSinceLastSeen < TimeSpan.Zero)
        {
            timeSinceLastSeen = timeSinceLastSeen.Negate();
        }

        if (timeSinceLastSeen.TotalMilliseconds < 1000)
        {
            output = implant.LastSeenTimer = $"{timeSinceLastSeen.Milliseconds} ms";
        }
        else if (timeSinceLastSeen.TotalSeconds < 60)
        {
            output = implant.LastSeenTimer = $"{timeSinceLastSeen.Seconds} sec";
        }
        else if (timeSinceLastSeen.TotalMinutes < 60)
        {
            output = implant.LastSeenTimer = $"{timeSinceLastSeen.Minutes} min";
        }
        else if (timeSinceLastSeen.TotalHours < 24)
        {
            output = implant.LastSeenTimer = $"{timeSinceLastSeen.Hours} hours";
        }
        else if (timeSinceLastSeen.TotalDays < 1)
        {
            output = implant.LastSeenTimer = $"{timeSinceLastSeen.Days} days";
        }
        else
        {
            output = implant.LastSeenTimer = $"{timeSinceLastSeen.Days} days";
        }
        OnStateChange();
        return output;
    }

    public static void ShowSuccessToast(string successMessage)
    {
        toastService.ShowSuccess(successMessage);
    }
    public static void ShowErrorToast(string errorMessage)
    {
        toastService.ShowError(errorMessage);
    }

    public static void ShowInfoToast(string infoMessage)
    {
        toastService.ShowInfo(infoMessage);
    }

    public static void ShowWarningToast(string warningmessage)
    {
        toastService.ShowWarning(warningmessage);
    }


    public async Task ImplementOnStateChangeEvent()
    {
        if (LastRefresh == null)
        {
            LastRefresh = DateTime.Now;
            InvokeAsync(StateHasChanged);
        }
        else
        {
            // if more then 500 ms has passed since the last refresh then refresh the page
            if (DateTime.Now.Subtract(LastRefresh.Value).TotalMilliseconds > 500)
            {
                LastRefresh = DateTime.Now;
                await Task.Delay(100);
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // _restClient = restClientDefault;
            // string jwtToken = await localStorage.GetItemAsync<string>("bearerToken");
            // RestClientOptions options = new RestClientOptions();
            // options.BaseUrl = _restClient.Options.BaseUrl;
            // options.RemoteCertificateValidationCallback = _restClient.Options.RemoteCertificateValidationCallback;
            // options.Authenticator = new JwtAuthenticator(jwtToken);
            // _restClient = new RestClient(options);
            await Implants.GetAllImplants();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        OnStateChange = ImplementOnStateChangeEvent;
        toastService = toastDefault;
        //nav here is used by the options menu to start interaction so dont remove
        Nav = navigationManagerDefault;

        if (stopwatch.IsRunning == false)
        {
            stopwatch.Start();
            Task.Run(() =>
            {
                while (true)
                {
                    if (stopwatch.ElapsedMilliseconds > 500)
                    {
                        OnStateChange();
                        stopwatch.Restart();
                    }
                    Thread.Sleep(100);
                }
            });
        }
    }


}
