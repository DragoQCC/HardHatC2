@using HardHatCore.HardHatC2Client.Pages;
@using Microsoft.AspNetCore.Components.Web;
@using MudBlazor;
@using HardHatCore.ApiModels.Plugin_BaseClasses;
@using HardHatCore.ApiModels.Plugin_Interfaces;
@using Blazored.LocalStorage;
@using HardHatCore.HardHatC2Client.Components;
@using HardHatCore.HardHatC2Client.Plugin_BaseClasses;
@using HardHatCore.HardHatC2Client.Plugin_Interfaces;
@using HardHatCore.HardHatC2Client.Plugin_Management;
@using HardHatCore.HardHatC2Client.Services;
@using HardHatCore.HardHatC2Client.Utilities;
@using RestSharp;
@using System.Collections.Generic;
@using System.Linq;
@using System.Diagnostics;
@using HardHatCore.ApiModels.Shared.TaskResultTypes;
@using HardHatCore.HardHatC2Client.Components.ImplantCreation


@if (Settings._InteractInputMode == InteractInputMode.Classic)
{
    <EditForm Context="EditFormContext" Model="implant" OnValidSubmit="@Send">
        <div class="d-flex mb-5">
            <MudAutocomplete style="@getPanelStyle()" MaxItems="@((AutocompleteSearchShowAllItems) ? (int?)null : 10)" Strict="false" OnKeyDown="OnShowCommandHistory" @bind-Value=@placeHolder T="string" ResetValueOnEmptyText="false" SearchFunc="@commandSelector.SearchCommand"
                             Dense="true" Margin="Margin.Dense" SelectValueOnTab="true" SelectOnClick="false" CoerceText="false" CoerceValue="true"
                             InputMode="InputMode.text" Variant="Variant.Outlined" Adornment="Adornment.Start" AdornmentText="[COMMAND]> " Immediate="true" Clearable="true" KeyDownPreventDefault="true" KeyUpPreventDefault="true" TextUpdateSuppression="@TextSuppersion">
            </MudAutocomplete>

            <MudButton style="background:var(--font-color);color:var(--background)" OnClick=@Send> <MudText>Send</MudText></MudButton>
            @if (IsEnterkey)
            {
                Task.Run(async () => await SendTask(implant, UserInput));
                IsEnterkey = false;
            }
        </div>
    </EditForm>
}
else if (Settings._InteractInputMode == InteractInputMode.NoAutoComplete)
{
    <EditForm Context="EditFormContext" Model="implant" OnValidSubmit="@Send">
        <div class="d-flex mb-5">
            <MudTextField style="@getPanelStyle()" OnKeyDown="OnShowCommandHistory" @bind-Value=@placeHolder T="string"
                          Margin="Margin.Dense" InputMode="InputMode.text" Variant="Variant.Outlined" Adornment="Adornment.Start" AdornmentText="[COMMAND]> " Immediate="true" Clearable="true"
                          TextUpdateSuppression="@TextSuppersion">
            </MudTextField>
            <MudButton style="background:var(--font-color);color:var(--background)" ButtonType="ButtonType.Submit"> <MudText>Send</MudText></MudButton>
            @if (IsEnterkey)
            {
                Task.Run(async () => await SendTask(implant, UserInput));
                IsEnterkey = false;
            }
        </div>
        <div class="d-flex mb-5">
            <MudAutocomplete style="@getPanelStyle()" @bind-Value=@placeHolder MaxItems="null" Strict="false" T="string" ResetValueOnEmptyText="true" SearchFunc="@commandSelector.SearchCommand"
                             Dense="true" Margin="Margin.Dense" SelectValueOnTab="true" SelectOnClick="true" CoerceText="true"
                             InputMode="InputMode.text" Variant="Variant.Outlined" Label="Search Commands" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" Immediate="true" Clearable="true" TextUpdateSuppression="@TextSuppersion">
            </MudAutocomplete>
        </div>
    </EditForm>
}
else
{
    <EditForm Context="EditFormContext" Model="implant" OnValidSubmit="@OnCommandSelectionEnterKeyDown">
        <div class="d-flex mb-xl-5">
            <CommandSelection @ref="commandSelector" Commands="@PluginService.GetCommandValidationPlugin(implant.ImplantType).CommandList" OnEnterKeyDown="OnCommandSelectionEnterKeyDown" />
            <MudButton style="background:var(--font-color);color:var(--background)" OnClick=@OnCommandSelectionEnterKeyDown> <MudText>Send</MudText></MudButton>
            @if (IsEnterkey)
            {
                Task.Run(async () => await SendTask(implant, UserInput));
                IsEnterkey = false;
            }
        </div>
    </EditForm>
}

@code {
    [Inject]
    private IDialogService _dialogService { get; set; }

    [Parameter]
    public ExtImplant_Base implant { get; set; }
    [Parameter]
    public EventCallback OnCommandSent { get; set; }

    public delegate Task OnWindowInteractSubmission();
    public static OnWindowInteractSubmission _onWindowInteractSubmission;
    private string placeHolder {get; set;} = null;
    private static List<string> PreviousCommands = new();
    private string selectedHistoryCommand = null;
    private static int HistoryIndex = -1;
    public static bool TextSuppersion = true;
    private CommandSelection commandSelector = new CommandSelection();


    private bool IsEnterkey { get; set; } = false;
    public static bool AutocompleteSearchShowAllItems { get; set; } = false;
    private static string UserInput { get; set; }

    public enum InteractInputMode
    {
        Classic,
        Inline,
        Modal_Window,
        NoAutoComplete
    }

    private string getPanelStyle()
    {
        string style = "";
        if (MainLayout.IsDarkMode)
        {
            style += "background:#1A1A27; color:white;";
        }
        else
        {
            style += "background:white; color:black;";
        }
        return style;
    }

    private async Task OnCommandSelectionEnterKeyDown()
    {
        await UpdateUserInput();
        await Send();
    }

    public async Task Send()
    {
        if (!String.IsNullOrWhiteSpace(placeHolder))
        {
            UserInput = placeHolder;
            TextSuppersion = false; //allows text box to be updated
            placeHolder = "";      // sets text back to empty
            IsEnterkey = true;
            await Task.Delay(2);
            TextSuppersion = true; // reset so textbox can be typed in without autoclearing until submission

            //if any of the strings in PreviousCommands matches UserInput then do not add it
            if (!PreviousCommands.Contains(UserInput))
            {
                PreviousCommands.Insert(0, UserInput);
            }
            HistoryIndex = -1;
        }
    }

    public async Task SendTask(ExtImplant_Base implant, string command)
    {
        try
        {
            var taskVal_base = PluginService.GetCommandValidationPlugin(implant.ImplantType);
            //parse input for aliases
            command = ImplantInteract.ParseInputForAliases(command, out string aliasParseError);
            if (!string.IsNullOrWhiteSpace(aliasParseError))
            {
                Implants.ShowErrorToast(aliasParseError);
                return;
            }


            Console.WriteLine("Starting send Task");
            string commandName = command.Split(' ')[0].Trim();

            //if command is help then run help and return
            if (commandName.Equals("help", StringComparison.CurrentCultureIgnoreCase))
            {
                Dictionary<string, string> helpDiction = new Dictionary<string, string>();
                string commandCheck = "";
                string helpCommandheader = "";
                if (command.Split(' ').Length > 2)
                {
                    commandCheck = command.Split(' ')[2];
                    helpCommandheader = $"({DateTime.UtcNow}) implant instructed to {commandName} {command.Split(' ')[1]} {command.Split(' ')[2]}\n";
                }
                else
                {
                    helpCommandheader = $"({DateTime.UtcNow}) implant instructed to {commandName}\n";
                }
                if (!string.IsNullOrWhiteSpace(commandCheck))
                {
                    helpDiction.Add("/command", commandCheck);
                }
                //List<Help.HelpMenuItem> helpMenu = Help.DisplayHelp(helpDiction);
                List<CommandItem> commandItemsHelp = taskVal_base.DisplayHelp(helpDiction);
                string helpTaskId = Guid.NewGuid().ToString();
                var helpTask = new ExtImplantTask_Base { Id = helpTaskId, Command = commandName, Arguments = helpDiction, File = null, TaskHeader = helpCommandheader };
                await ImplantInteract.UpdateOutGoingTaskDic(implant, new List<ExtImplantTask_Base>() { helpTask });

                var taskResponse = new ExtImplantTaskResult_Base();
                taskResponse.Id = helpTaskId;
                taskResponse.Status = ExtImplantTaskStatus.Complete;
                taskResponse.ResponseType = ExtImplantTaskResponseType.HelpMenuItem;
                taskResponse.ResultObject = commandItemsHelp;

                ImplantInteract.TaskResultDic.Add(helpTask, taskResponse);
                return; //return here because help command does not need to be sent to the engineers
            }

            Dictionary<string, string> commandargs = new Dictionary<string, string>();
            string error = null;

            bool _requiresPostProc = false;
            bool _requiresPreProc = false;
            //find the command in the helpMenuItems list that matches the command name
            CommandItem? commandItem = taskVal_base.CommandList.FirstOrDefault(x => x.Name.Equals(commandName, StringComparison.OrdinalIgnoreCase));
            if (commandItem != null)
            {
                _requiresPostProc = commandItem.RequiresPostProc;
                _requiresPreProc = commandItem.RequiresPreProc;
                if (commandItem.Opsec == CommandItem.OpsecStatus.Blocked)
                {
                    error = "Command is blocked by teamlead";
                }
                else if (commandItem.Opsec == CommandItem.OpsecStatus.High)
                {
                    //we want to spawn a message box to get a yes or a no here ,if the user says no then return false, if the user says yes then continue
                    bool? result = null;
                    await InvokeAsync(async () =>
                    {
                        result = await _dialogService.ShowMessageBox("Opsec Warning", "Command is set to High opsec danger level, are you sure you want to execute?", yesText: "Fire Away!", cancelText: "Cancel");
                    });
                    //bool? result =  messageBoxTask.Result;
                    if (result is null || result == false)
                    {
                        error = "Command Cancelled by user";
                    }
                    else
                    {
                        taskVal_base.ValidateCommand(command, out commandargs, out error);
                    }
                }
                else
                {
                    taskVal_base.ValidateCommand(command, out commandargs, out error);
                }
            }
            else
            {
                taskVal_base.ValidateCommand(command, out commandargs, out error);
            }
            if (error != null)
            {
                Implants.ShowErrorToast(error);
                return;
            }

            Dictionary<string,byte[]> _taskingExtras = new();

            //check if createObject.Command is one of the postex that make a new implant
            if (ImplantCreation.ImplantCreation.PostExCommandsThatSpawnNewImp is not null && ImplantCreation.ImplantCreation.PostExCommandsThatSpawnNewImp.Contains(commandName, StringComparer.InvariantCultureIgnoreCase))
            {
                var diag_options = new DialogOptions { ClassBackground = "dialog-blur-class", MaxWidth = MaxWidth.Large, FullWidth = true, DisableBackdropClick = true };
                //invoke async needs to used to trigger the render to work correctly from inside c# code
                await InvokeAsync(async () =>
                {
                    var diagTask = _dialogService.Show<ImplantCreation_Dialog>("Create Implant for PostEx Command", diag_options);
                    var result = await diagTask.Result;
                    if (result.Canceled)
                    {
                        return;
                    }
                    else
                    {
                        _taskingExtras.Add("PostExImplantRequest", ImplantCreation_Dialog.PostExSpawnRequest.Serialize());
                    }
                });
            }
            byte[] _file = null;
            //if commandargs contains a /local key we should update the file content
            if (commandargs.ContainsKey("/local"))
            {
                // check each command arg to see if it contains a file path
                foreach (KeyValuePair<string, string> kvp in commandargs)
                {
                    if (File.Exists(kvp.Value))
                    {
                        _file = File.ReadAllBytes(kvp.Value);
                    }
                }
                if (!(_file.Length > 0))
                {
                    Implants.ShowErrorToast("/local flag used but no matching file found on client");
                    return;
                }
            }

            bool _isBlocking = false;
            //if arguments contains /method as a key then if the value is sync set the IsBlocking parameter to true if its async set it to false, if the key is not present set it to false
            if (commandargs.ContainsKey("/sync"))
            {
                //createObject.Arguments["/method"] = createObject.Arguments["/method"];
                if (commandargs["/sync"].Equals("sync", StringComparison.CurrentCultureIgnoreCase))
                {
                    _isBlocking = true;
                }
            }
            
            var requestObject = new TaskExtImplantRequest_Base(commandName,commandargs, _file, _isBlocking, _requiresPreProc, _requiresPostProc, _taskingExtras);

            //send the task to the server
            string resource = $"/implants/{implant.Metadata.Id}";
            var request = new RestRequest(resource, Method.Post);
            request.AddJsonBody(requestObject);
            request.OnBeforeDeserialization = (resp =>
            {
                //Console.WriteLine(resp.Content);
            });
            ImplantInteract.RefreshImplantInteract.Invoke();
            var taskingResult = await Task.Run(() => Login._restClient.PostAsync<ExtImplantTask_Base>(request));
            if (taskingResult is not null)
            {
                Console.WriteLine("Tasking Successful");
                await ImplantInteract.UpdateOutGoingTaskDic(implant, new List<ExtImplantTask_Base>() { taskingResult});  
            }
            else
            {
                Console.WriteLine("Tasking Failed");
                Implants.ShowErrorToast("Tasking Failed");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            Console.WriteLine(ex.StackTrace);
        }
    }
    // end of send task function

    private async Task UpdateUserInput()
    {
        if (commandSelector.SelectedCommandItem != null)
        {
            var selectedCommand = commandSelector.SelectedCommandItem.Name;

            // Filter out keys with empty values
            var keyValuePairs = commandSelector.keyValue.Where(kvp => !string.IsNullOrEmpty(kvp.Value));

            // Build the command string with key-value pairs
            var commandString = selectedCommand + " " + string.Join(" ", keyValuePairs.Select(kvp => $"{kvp.Key} {kvp.Value}"));
            placeHolder = commandString.Trim();
        }
    }

    private async Task OnShowCommandHistory(KeyboardEventArgs e)
    {
        if (PreviousCommands.Count > 0)
        {
            //check to make sure the key pressed was the up arrow
            if (e.Code == "ArrowUp")
            {
                HistoryIndex++;
                if (HistoryIndex > (PreviousCommands.Count - 1))
                {
                    HistoryIndex = (PreviousCommands.Count - 1);
                }
                //get the Historyindex, set placeholder text to the history item at that index, and increment the index
                if (HistoryIndex <= PreviousCommands.Count)
                {
                    if (HistoryIndex < 0)
                    {
                        HistoryIndex = 0;
                    }
                    //Task.Run(async () => await GetCommandHistory());
                    await GetCommandHistory();
                }
            }
            else if (e.Code == "ArrowDown")
            {
                HistoryIndex--;
                if (HistoryIndex < -1)
                {
                    //if index is less than -1 set it to -1 and update the placeholder text to be blank
                    HistoryIndex = -1;
                    TextSuppersion = false; //allows text box to be updated
                    placeHolder = "";
                    await Task.Delay(500);
                    TextSuppersion = true; // reset so textbox can be typed in without autoclearing until submission
                }
                //get the Historyindex, set placeholder text to the history item at that index, and decrement the index
                if (HistoryIndex >= 0)
                {
                    //Task.Run(async () => await GetCommandHistory());
                    await GetCommandHistory();
                }
            }
        }
    }

    private async Task GetCommandHistory()
    {
        TextSuppersion = false; //allows text box to be updated
        placeHolder = PreviousCommands[HistoryIndex];
        await Task.Delay(500);
        TextSuppersion = true; // reset so textbox can be typed in without autoclearing until submission
    }

    protected override Task OnParametersSetAsync()
    {
        commandSelector = new CommandSelection(implant.ImplantType);
        return base.OnParametersSetAsync();
    }

    protected override async Task OnInitializedAsync()
    {
        _onWindowInteractSubmission = OnCommandSelectionEnterKeyDown;
    }

}
